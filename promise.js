//@ sourceMappingURL=promise.map
// Generated by CoffeeScript 1.6.1
(function() {
  var Covenant, Promise, root,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Covenant = require('./covenant').Covenant;

  Promise = (function(_super) {

    __extends(Promise, _super);

    function Promise() {
      var _this = this;
      this.thenable = function() {
        return Promise.prototype.thenable.apply(_this, arguments);
      };
      this.resolver = function() {
        return Promise.prototype.resolver.apply(_this, arguments);
      };
      Promise.__super__.constructor.call(this);
    }

    Promise.pending = function() {
      return new Promise;
    };

    Promise.fulfilled = function(value) {
      var p;
      p = new Promise;
      p.fulfill(value);
      return p;
    };

    Promise.rejected = function(reason) {
      var p;
      p = new Promise;
      p.reject(reason);
      return p;
    };

    Promise.fromNode = function(f) {
      return function() {
        var args, p;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        p = new Promise;
        args.push(function(err, value) {
          if (err) {
            return p.reject(err);
          } else {
            return p.fulfill(value);
          }
        });
        f.apply(null, args);
        return p;
      };
    };

    Promise.delay = function(ms) {
      var p;
      p = new Promise;
      setTimeout((function() {
        return p.fulfill();
      }), ms);
      return p;
    };

    Promise.timeout = function(ms, p) {
      setTimeout((function() {
        return p.reject(new Error("timeout after " + ms + " milliseconds"));
      }), ms);
      return p;
    };

    Promise.all = Promise.when;

    Promise.when = function() {
      var i, p, pAll, promises, _fn, _i, _len,
        _this = this;
      promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      pAll = this.pending();
      pAll.results = new Array(promises.length);
      pAll.numLeft = promises.length;
      if (promises.length === 0) {
        pAll.fulfill([]);
      } else {
        _fn = function(p, i) {
          return _this._scheduleResolution(pAll, p, i);
        };
        for (i = _i = 0, _len = promises.length; _i < _len; i = ++_i) {
          p = promises[i];
          _fn(p, i);
        }
      }
      return pAll;
    };

    Promise.prototype.done = function(onFulfill) {
      return this.then(onFulfill);
    };

    Promise.prototype.fail = function(onReject) {
      return this.then(null, onReject);
    };

    Promise.prototype.always = function(callback) {
      return this.then(callback, callback);
    };

    Promise.prototype.resolver = function() {
      return {
        reject: this.reject,
        fulfill: this.fulfill
      };
    };

    Promise.prototype.thenable = function() {
      return {
        then: this.then,
        done: this.done,
        fail: this.fail,
        always: this.always
      };
    };

    Promise._scheduleResolution = function(pAll, valOrPromise, i) {
      if (Promise._isPromise(valOrPromise)) {
        return valOrPromise.then((function(value) {
          return Promise._scheduleResolution(pAll, value, i);
        }), pAll.reject);
      } else {
        pAll.results[i] = valOrPromise;
        if (--pAll.numLeft === 0) {
          return pAll.fulfill(pAll.results);
        }
      }
    };

    Promise._isPromise = function(p) {
      return typeof (p != null ? p.then : void 0) === 'function';
    };

    return Promise;

  }).call(this, Covenant);

  root.Promise = Promise;

}).call(this);
