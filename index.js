// Generated by CoffeeScript 1.6.2
(function() {
  var CompletedState, Covenant, FulfilledState, PendingState, Promise, PromiseStream, RejectedState, Transform, bestTick, root, secondBestTick, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.bestTick = (typeof process !== "undefined" && process !== null ? process.nextTick : void 0) || (typeof setImmediate === 'function' && setImmediate) || function(task) {
    return setTimeout(task, 0);
  };

  root.secondBestTick = (typeof setImmediate === 'function' && setImmediate) || function(task) {
    return setTimeout(task, 0);
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ref = require('./bestTick'), bestTick = _ref.bestTick, secondBestTick = _ref.secondBestTick;

  Covenant = (function() {
    function Covenant() {
      this.then = __bind(this.then, this);
      this.reject = __bind(this.reject, this);
      this.fulfill = __bind(this.fulfill, this);      this.state = new PendingState;
    }

    Covenant.prototype.fulfill = function(value) {
      return this.state = this.state.fulfill(value);
    };

    Covenant.prototype.reject = function(reason) {
      return this.state = this.state.reject(reason);
    };

    Covenant.prototype.then = function(onFulfill, onReject) {
      var p2;

      p2 = new this.constructor;
      this.state._schedule(onFulfill, onReject, p2);
      return p2;
    };

    return Covenant;

  })();

  root.Covenant = Covenant;

  PendingState = (function() {
    function PendingState() {
      this.pendeds = [];
    }

    PendingState.prototype.fulfill = function(value) {
      return new FulfilledState(value, this.pendeds);
    };

    PendingState.prototype.reject = function(reason) {
      return new RejectedState(reason, this.pendeds);
    };

    PendingState.prototype._schedule = function(f, r, p) {
      return this.pendeds.push([f, r, p]);
    };

    return PendingState;

  })();

  CompletedState = (function() {
    function CompletedState(pendeds) {
      var pended, _fn, _i, _len,
        _this = this;

      _fn = function(pended) {
        return _this._schedule.apply(_this, pended);
      };
      for (_i = 0, _len = pendeds.length; _i < _len; _i++) {
        pended = pendeds[_i];
        _fn(pended);
      }
    }

    CompletedState.prototype.fulfill = function() {
      return this;
    };

    CompletedState.prototype.reject = function() {
      return this;
    };

    CompletedState.prototype._do = function(datum, callback, fallback, p2) {
      if (this._isFunction(callback)) {
        return this._handleFunction.apply(this, arguments);
      } else {
        return fallback(datum);
      }
    };

    CompletedState.prototype._handleFunction = function(datum, callback, fallback, p2) {
      var e;

      try {
        return this._handleFunctionResult.apply(this, arguments);
      } catch (_error) {
        e = _error;
        return p2.reject(e);
      }
    };

    CompletedState.prototype._handleFunctionResult = function(datum, callback, fallback, p2) {
      var result,
        _this = this;

      if (this._isPromise(result = callback(datum))) {
        return setImmediate(function() {
          return result.then(p2.fulfill, p2.reject);
        });
      } else {
        return p2.fulfill(result);
      }
    };

    CompletedState.prototype._isFunction = function(thing) {
      return typeof thing === 'function';
    };

    CompletedState.prototype._isPromise = function(thing) {
      return this._isFunction(thing != null ? thing.then : void 0);
    };

    return CompletedState;

  })();

  FulfilledState = (function(_super) {
    __extends(FulfilledState, _super);

    function FulfilledState(value, pended) {
      this.value = value;
      FulfilledState.__super__.constructor.call(this, pended);
    }

    FulfilledState.prototype._schedule = function(onFulfill, __, p2) {
      var _this = this;

      return bestTick(function() {
        return _this._do(_this.value, onFulfill, p2.fulfill, p2);
      });
    };

    return FulfilledState;

  })(CompletedState);

  RejectedState = (function(_super) {
    __extends(RejectedState, _super);

    function RejectedState(reason, pended) {
      this.reason = reason;
      RejectedState.__super__.constructor.call(this, pended);
    }

    RejectedState.prototype._schedule = function(__, onReject, p2) {
      var _this = this;

      return bestTick(function() {
        return _this._do(_this.reason, onReject, p2.reject, p2);
      });
    };

    return RejectedState;

  })(CompletedState);

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Covenant = require('./covenant').Covenant;

  Transform = require('stream').Transform;

  PromiseStream = (function(_super) {
    __extends(PromiseStream, _super);

    function PromiseStream(promise, options) {
      this.promise = promise;
      this.options = options != null ? options : {
        passthrough: "false"
      };
      this.chunks = null;
      PromiseStream.__super__.constructor.call(this);
      this.on('error', this.promise.reject);
      if (!this.options.passthrough) {
        this.resume();
      }
      this;
    }

    PromiseStream.prototype._transform = function(chunk, encoding, callback) {
      this._collect(chunk, encoding, callback);
      if (this.options.passthrough) {
        return callback(null, chunk);
      }
    };

    PromiseStream.prototype.end = function() {
      this.promise.fulfill(this._joinCollection);
      return PromiseStream.__super__.end.call(this);
    };

    PromiseStream.prototype._collect = function(chunk, encoding, callback) {
      if (this.chunks) {
        return this.chunks += chunk;
      } else {
        return this.chunks = chunk;
      }
    };

    PromiseStream.prototype._joinCollection = function() {
      return this.chunks;
    };

    return PromiseStream;

  })(Transform);

  root.PromiseStream = PromiseStream;

  Promise = (function(_super) {
    __extends(Promise, _super);

    function Promise() {
      this._httpResolver = __bind(this._httpResolver, this);
      this._nodeResolver = __bind(this._nodeResolver, this);
      this.thenable = __bind(this.thenable, this);
      this.resolver = __bind(this.resolver, this);
      this.stream = __bind(this.stream, this);      Promise.__super__.constructor.call(this);
    }

    Promise.makePromise = function(f) {
      var p;

      p = new Promise;
      f(p);
      return p;
    };

    Promise.pending = function() {
      return Promise.makePromise(function() {});
    };

    Promise.fulfilled = function(value) {
      return Promise.makePromise(function(p) {
        return p.fulfill(value);
      });
    };

    Promise.rejected = function(reason) {
      return Promise.makePromise(function(p) {
        return p.reject(reason);
      });
    };

    Promise.fromNode = function(f) {
      return function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Promise.makePromise(function(p) {
          return f.apply(null, __slice.call(args).concat([p._nodeResolver]));
        });
      };
    };

    Promise.delay = function(ms) {
      return Promise.makePromise(function(p) {
        setTimeout(p.fulfill, ms);
        return p.always(function() {
          return clearTimeout(t);
        });
      });
    };

    Promise.timeout = function(ms, p) {
      return Promise.makePromise(function(p2) {
        var err, t;

        err = new Error("timeout after " + ms + " milliseconds");
        t = setTimeout((function() {
          return p.reject(err);
        }), ms);
        p.then(p2.fulfill, p2.reject);
        return p.always(function() {
          return clearTimeout(t);
        });
      });
    };

    Promise.when = function() {
      var promises;

      promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Promise.makePromise(function(pAll) {
        var i, p, _i, _len, _results;

        pAll.results = new Array(promises.length);
        pAll.numLeft = promises.length;
        if (promises.length === 0) {
          return pAll.fulfill([]);
        } else {
          _results = [];
          for (i = _i = 0, _len = promises.length; _i < _len; i = ++_i) {
            p = promises[i];
            _results.push((function(p, i) {
              return Promise._scheduleResolution(pAll, p, i);
            })(p, i));
          }
          return _results;
        }
      });
    };

    Promise.all = Promise.when;

    Promise.prototype.done = function(onFulfill) {
      return this.then(onFulfill);
    };

    Promise.prototype.fail = function(onReject) {
      return this.then(null, onReject);
    };

    Promise.prototype.always = function(callback) {
      return this.then(callback, callback);
    };

    Promise.prototype.stream = function(options) {
      return new PromiseStream(this, options);
    };

    Promise.prototype.resolver = function() {
      return {
        reject: this.reject,
        fulfill: this.fulfill
      };
    };

    Promise.prototype.thenable = function() {
      return {
        then: this.then,
        done: this.done,
        fail: this.fail,
        always: this.always
      };
    };

    Promise._scheduleResolution = function(pAll, valOrPromise, i) {
      if (Promise._isPromise(valOrPromise)) {
        return valOrPromise.then((function(value) {
          return Promise._scheduleResolution(pAll, value, i);
        }), pAll.reject);
      } else {
        pAll.results[i] = valOrPromise;
        if (--pAll.numLeft === 0) {
          return pAll.fulfill(pAll.results);
        }
      }
    };

    Promise._isPromise = function(p) {
      return typeof (p != null ? p.then : void 0) === 'function';
    };

    Promise.prototype._nodeResolver = function(err, value) {
      if (err) {
        return this.reject(err);
      } else {
        return this.fulfill(value);
      }
    };

    Promise.prototype._httpResolver = function(res) {
      if (res.statusCode === 201) {
        return res.pipe(this.stream());
      } else {
        return this.reject(new Error("HTTP status code " + res.statusCode));
      }
    };

    return Promise;

  }).call(this, Covenant);

  root.Promise = Promise;

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
